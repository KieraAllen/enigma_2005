## [Enigma](https://backend.turing.io/module1/projects/enigma/index) (codename: _Winnie_)<br/>
Created by [Kiera Allen](https://github.com/KieraAllen)

### Week 6 Independent Project (2005 BE)
Use Ruby to build a tool for cracking an encryption algorithm.

### Learning Goals / Areas of Focus
- Practice breaking a program into logical components
- Build classes that demonstrate single responsibilities
- Test drive a well-designed Object Oriented solution
- Work with file i/o

### Self-Assessment
Based on [this rubric](https://backend.turing.io/module1/projects/enigma/rubric), this is how I assess the project:

**Functionality** - *Meets Expectations*  
Project includes `Enigma` Class with `encrypt` and `decrypt` methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented)  

**Object Oriented Programming** - *Meets Expectations*  
Project is broken into logical components that are appropriately encapsulated. No classes are unreasonably small or large, or contain knowledge/information/behavior that they shouldnâ€™t know about. Student can articulate the single responsibilities of the various components.

**Ruby Convention and Mechanics** - *Meets Expectations*  
Code is mostly properly indented, spaced, and lines are not excessively long. Class, method, variable, and file names follow convention. Some enumerables/data structures chosen are the most efficient tool for a given job, and students can speak as to why those enumerables/data structures were chosen. At least one hash is implemented in a way that makes logical sense.

**Test-Driven Development** - *Meets Expectations*  
Every method is tested at both the unit and integration level, and completely verify expected behavior (i.e., if a single method does 3 things, all 3 things are explicitly tested). Obvious edge cases are addressed. git history demonstrates students are writing tests before implementation code. Test coverage metrics show coverage at 99% or greater.  

**Version Control** - *Above Expectations*  
At least 40 commits. All pull requests include related and logical chunks of functionality, and are named and documented to clearly communicate the purpose of the pull request. No commits include multiple pieces of functionality. No commit message is ambiguous.
